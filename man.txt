TYPES:
    BOOL:       NIL, T
    INTEGER:    LONG INT
    RATIONAL:   LONG INT / LONG INT
    NUMBER:     INTEGER, RATIONAL
    STRING:     "DYNAMIC LENGTH"
    IDENTIFIER: 'VALUE_NAME'
    CONS:       (...), (CAR . CDR)
    SET:        {...},{ TAU : ...TAU...}

FUNCTION:   *
INPUT:      NUMBER_1 ... NUMBER_k
OUTPUT:     NUMBER
FUNCTION:   +
INPUT:      NUMBER_1 ... NUMBER_k
OUTPUT:     NUMBER
FUNCTION:   /
INPUT:      NUMBER_1 ... NUMBER_k
OUTPUT:     NUMBER
FUNCTION:   <
INPUT:      NUMBER_1 NUMBER_2
OUTPUT:     BOOL
FUNCTION:   <=
INPUT:      NUMBER_1 NUMBER_2
OUTPUT:     BOOL
FUNCTION:   =
INPUT:      NUMBER_1 NUMBER_2
OUTPUT:    	BOOL
FUNCTION:   =>
INPUT:      BOOL
OUTPUT:     BOOL
FUNCTION:   >
INPUT:      NUMBER_1 NUMBER_2
OUTPUT:     BOOL
FUNCTION:   >=
INPUT:      NUMBER_1 NUMBER_2
OUTPUT:    	BOOL
FUNCTION:   \
INPUT:      SET_1 SET_2
OUTPUT:    	SET
NOTES:		SET DIFFERENCE, WORKS FOR BOTH COMPREHENSION OR BOTH EXTENSION SET
FUNCTION:   POW
INPUT:      NUMBER INTEGER
OUTPUT:    	NUMBER
NOTES:		INTEGER MUST BE POSITIVE
FUNCTION:   AND
INPUT:      BOOL_1 ... BOOL_k
OUTPUT:    	BOOL

	{"append", F_union, "(LIST_1 ... LIST_k) -> LIST"},
	{"assoc", F_assoc, "(IDENTIFIER ((X_1 V_1) ... (X_N V_N))) -> V_I"},
	{"atomp", F_atom, "X -> [NIL|T]"},
	{"bquote", F_bquote, "EXPR -> EXPR"},
	{"cap", F_cap, "LIST_1 LIST_2 -> LIST"},
	{"car", F_car, "LIST -> VALUE"},
	{"cat", F_cat, "(STRING_1 STRING_2) -> STRING"},
	{"cdr", F_cdr, "LIST -> LIST"},
	{"comma", F_comma, "EXPR -> EXPR"},
	{"comp", F_complement, "SET -> SET"},
	{"cond", F_cond, "(((COND_1) (EXPR_1)) ... ((COND_N) EXPR_N)) -> VAL "},
	{"cons", F_cons, "(X_1 X_2) -> CONS"},
	{"consp", F_consp, "X -> [NIL|T]"},
	{"define", F_setq, "(VAR_1 VAL_1 ... VAR_k VAL_k) -> VAL_k"},
	{"defmacro", F_defmacro, "(<= X_1 X_2)"},
	{"diff", F_diff, "(CONS CONS) -> CONS"},
	{"dump", F_dump, "?POOL -> T"},
	{"eq", F_eq, "(X_1 X_2) -> [NIL|T]"},
	{"eval", F_eval, "EXPR -> EXPR"},
	{"evlis", F_evlis, "((LIST_1) ... (LIST_N)) -> ( (EVAL LIST_1) ... (EVAL LIST_N))"},
	{"help", F_help, "FUNC -> [NIL|T]"},
	{"if", F_if, "(COND EXPR_T EXPR_NIL) -> EXPR"},
	{"in", F_member, "X Y -> NIL|T"},
	{"labels", F_labels, "((FUN_1) ... (FUN_m)) EXPR_1 .. EXPR_k) -> EXPR_k"},
	{"let", F_let, "((ID_1 VAL_1) ... (ID_m VAL_m)) EXPR_1 .. EXPR_k) -> EXPR_k"},
	{"list", F_list, "(X_1 X_2 .. X_k) -> LIST"},
	{"load", F_loadfile, "IDENTIFIER"},
	{"map", F_map, "(FUNCTION LIST) -> LIST"},
	{"memberp", F_member, "(X_1 LIST) -> [NIL|T]"},
	{"mod", F_mod, "INT_1 INT_2 -> INT"},
	{"not", F_not, "BOOL -> BOOL"},
	{"notin", F_notin, "SET -> [NIL|T]"},
	{"nth", F_nth, "CONS -> X"},
	{"numberp", F_numberp, "X -> [NIL|T]"},
	{"or", F_or, "(BOOL_1 ... BOOL_n) -> [NIL|T]"},
	{"ord", F_ord, "LIST -> NUM"},
	{"par", F_pair, "(LIST_1 LIST_2) -> LIST"},
	{"pop", F_pop, "STACK -> X"},
	{"pow", F_powerset, "SET->SET"},
	{"print", F_print, "OBJECT -> NULL"},
	{"prod", F_setprod, "SET SET -> SET"},
	{"prog1", F_prog1, "EXPR_1 ... EXPR_N -> EVAL(EXPR_1)"},
	{"prog2", F_prog2, "EXPR_1 ... EXPR_N -> EVAL(EXPR_2)"},
	{"progn", F_progn, "EXPR_1 ... EXPR_N -> EVAL(EXPR_N)"},
	{"push", F_push, "(X STACK) -> STACK"},
	{"quit", F_quit, ""},
	{"quote", F_quote, "X -> IDENTIFIER"},
	{"seq", F_seq, "INT_1 INT_2 -> LIST"},
	{"strlen", F_strlen, "STRING -> NUM"},
	{"subset", F_subset, "(SET SET) -> [NIL|T]"},
	{"subst", F_subst, "(X Y (X_1 ... X_N)) -> LIST"},
	{"substr", F_substr, "(NUM_1 NUM_2 STRING) -> STRING"},
	{"symdiff", F_symdiff, "SET SET -> SET"},
	{"typeof", F_typeof, "X -> T"},
	{"undef", F_undef, "VAR -> [NIL|T]"},
	{"union", F_union, "SET SET -> SET"},
	{"xor", F_xor, "(BOOL_1 ... BOOL_n) -> [NIL|T]"},
